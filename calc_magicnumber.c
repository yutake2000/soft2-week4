#include <stdio.h>
#include <stdlib.h>

/*

実行環境:
macOS Catalina (バージョン10.15.7)
gcc --version
	Configured with: --prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/4.2.1
	Apple clang version 11.0.3 (clang-1103.0.32.29)
	Target: x86_64-apple-darwin19.6.0
	Thread model: posix

文字列を表すバイト列を4バイトずつfloatとして読み込み、小数点以下9桁まで表示している。
これをhelloworld.cのfに代入し、文字列として出力する。

フォーマット
%f
	f[0]	1143139122437582505939828736.000000
	f[1]	66592994030331831990133719040.000000
	f[2]	0.000000
%ef
	f[0]	1.143139e+27f
	f[1]	6.659299e+28f
	f[2]	1.099820e-32f
%.9ef
	f[0]	1.143139122e+27f
	f[1]	6.659299403e+28f
	f[2]	1.099819698e-32f

helloworld.cで表示される文字列
	%f:   Hello,Wo(\0)
	%ef:  Felln,Wovld(\n)
	%.9ef Hello,World(\n)

4バイトずつfloatとして読み込んでいるので
f[0]が"hell", f[1]が"o,wo", f[2]が"rld\n", f[3]が"\0"
に対応する。

フォーマット"%f"のとき
	f[0],f[1]はすべての桁を表示しているので問題ない。
	f[2]は値が小さいので0と表示されてしまい、文字列の終端記号として解釈された。

フォーマット"%ef"のとき
	f[2]が0でなくなったことで全て表示はされたが、所々間違っている。
	間違っている場所は1文字目、5文字目、9文字目(4バイトで区切ったときの最初のバイト)。
	誤差は仮数部の後ろの方(下位バイト)に影響するが、
	リトルエンディアン方式ではそれが上位バイトとしてメモリに収納されている影響と考えられる。

フォーマット"%.9ef"のとき
	精度が十分だったため正しく表示された。

小数点以下を何桁まで表示すれば正しく表示されるのか。
f[0] = 1.1431391f  のとき最初の文字は'H'
f[0] = 1.14313905f のとき最初の文字は'G'
f[0] = 1.1431390f  のとき最初の文字は'F'
となることから、'G'を頭文字としたければもう一桁必要なことがわかる。
よって少なくとも小数点以下8桁は必要となる。

floatの仮数部は23ビットだが、1の位は省略される(けち表現)ので実際には24ビット分表せる。
2^24 = 1.7*10^7 なので、10進数では8桁程度表せるということになる。
よって9桁(一の位と小数点以下8桁)あれば大抵のビット列(-0やinfなど特別なものを除く)が表せる。
ただし、小数点以下9桁を四捨五入または切り捨てした結果1つずれてしまう可能性はあるので、
出力された値をそのまま使って確実に復元できるかどうかはわからない。
(1つずれた場合でも小数第八位を1つずらすことで元の文字を表示することは可能。)

繰り上がりの可能性がある以上何桁であっても(すべての桁を表示する場合を除いて)確実に復元できるとは言えない。
ただし、桁数が増えるごとに繰り上がりの可能性は低くなるので15桁程度あればほぼ確実に復元できると考えられる。

調整さえすれば小数第八位までの浮動小数点数リテラルで(-0やinfなどを除く)ほぼすべてのビット列を表すことは可能。

*/

int main(void) {

	FILE* fp = fopen("helloworld.txt", "rb");
	if (fp == NULL)
		return 1;

	float nums[3];
	fread(&nums, sizeof(float), 3, fp);
	fclose(fp);

	for (int i=0; i<3; i++) {
		printf("%.9ef\n", nums[i]);
	}

 	return 0;
}
